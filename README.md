# Task 1: Stack
![screen.png](https://github.com/Danchess17/mipt2024s-3-ishkhanian-d/blob/main/screen.png)
![push1.png](https://github.com/Danchess17/mipt2024s-3-ishkhanian-d/blob/main/push1.png)
![push1.png](https://github.com/Danchess17/mipt2024s-3-ishkhanian-d/blob/main/push2.png)
![pop1.png](https://github.com/Danchess17/mipt2024s-3-ishkhanian-d/blob/main/pop1.png)
![pop2.png](https://github.com/Danchess17/mipt2024s-3-ishkhanian-d/blob/main/pop2.png)
### Выводы:
1) Тест 1 показал, что конструктор стека на списке быстрее конструктора на массиве (с дефолтной capacity = 8) в 10 раз.
2) Тесты 2, 3, 4, 6, 7 показали, что функции push, pop, top (по отдельности) работают быстрее для массива, чем соответствующие для списка.
3) Тесты 2, 3, 4, 6, 7 показали, что суммарное время работы функций push, pop, top (примененные последовательно в связке друг с другом) меньше для массива, чем для списка.
4) Тест 5 показал, что вызов функций стека в рандомном хаотичном порядке в среднем по времени одинаковый для стеков, то есть, при неразумном использовании невозможно определить, кто лучше.
5) Тест 7 показал, что несмотря на пункт 1, вызов конструктора + последовательные push, pop будут работать быстрее для стека на массиве примерно в 2 раза.
6) Также были по результатам теста 5 и теста 6 были построены графики зависимости времени работы от количества вызова функции push и pop.
7) У chrono достаточно большая для нашей задачи погрешность (больше наносекунды), поэтому для рисования графиков приходилось замерять время раз в 100 push/pop, а не на каждой итерации.
8) На них видим, что и для pusha, и для popa в случае стека на массиве заметны резкие скачки затрат по времени, соответствующие аллокации/деаллокации памяти соответственно.
9) На графиках видно, что стек на массиве быстрее стека на списке.
10) При компиляции c флагом -O3 соотношение скоростей push и pop для массива и списка было уже не трехкратным, а семикратным. 
11) В целом, можно сказать, что стек на расширяющемся массиве работает быстрее, чем на односвязном списке.

